<!doctype html><html lang=en><head><title>Raspberry Pi 5's NVMe is a Killer Feature :: Buffer Overflow</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Running a Kubernetes cluster on a few Raspberry Pi 4s has been a rewarding but challenging experience. The biggest limitation was storage - each Pi was booting from an SD card, which, while convenient, proved to be a massive bottleneck. SD cards are not only slow, but also wear out quickly under constant read/write operations. Over time, I experienced several cases of data corruption which brought that cluster to its knees.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/pi-5-nvme-killer-feature/><link rel=stylesheet href=/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css><link rel=stylesheet href=/css/code.min.00125962708925857e7b66dbc58391d55be1191a3d0ce2034de8c9cd2c481c36.css><link rel=stylesheet href=/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css><link rel=stylesheet href=/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css><link rel=stylesheet href=/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css><link rel=stylesheet href=/css/main.min.fe8dc560fccb53a458b0db19ccb7b265764ac46b68596b7e099c6793054dd457.css><link rel=stylesheet href=/css/menu.min.83637a90d903026bc280d3f82f96ceb06c5fc72b7c1a8d686afb5bbf818a29f7.css><link rel=stylesheet href=/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css><link rel=stylesheet href=/css/post.min.fc74ca360273c1d828da3c02b8174eba435607b369d98418ccc6f2243cd4e75d.css><link rel=stylesheet href=/css/prism.min.9023bbc24533d09e97a51a0a42a5a7bfe4c591ae167c5551fb1d2191d11977c0.css><link rel=stylesheet href=/css/syntax.min.cc789ed9377260d7949ea4c18781fc58959a89287210fe4edbff44ebfc1511b6.css><link rel=stylesheet href=/css/terminal.min.dd0bf9c7cacb24c1b0184f52f1869b274e06689557468cc7030ccf632328eb97.css><link rel=stylesheet href=/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=/style.css><link rel="shortcut icon" href=/favicon.png><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Raspberry Pi 5's NVMe is a Killer Feature"><meta property="og:description" content="Running a Kubernetes cluster on a few Raspberry Pi 4s has been a rewarding but challenging experience. The biggest limitation was storage - each Pi was booting from an SD card, which, while convenient, proved to be a massive bottleneck. SD cards are not only slow, but also wear out quickly under constant read/write operations. Over time, I experienced several cases of data corruption which brought that cluster to its knees.
"><meta property="og:url" content="/posts/pi-5-nvme-killer-feature/"><meta property="og:site_name" content="Buffer Overflow"><meta property="og:image" content="/images/2024/02/RPi5.jpg"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2024-02-16 00:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Buffer Overflow</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>Home</a></li><li><a href=/about>About me</a></li><li><a href=/notes>Notes</a></li><li><a href=/posts>Blog</a></li><li><a href=https://github.com/danclough>Code</a></li><li><a href=https://infosec.exchange/@danclough>Mastodon</a></li><li><a href="https://bellard.org/jslinux/vm.html?cpu=riscv64&amp;url=buildroot-riscv64.cfg&amp;mem=256">Exit</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><ul class=menu><li class=menu__trigger>File&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/>Home</a></li><li><a href=/about>About me</a></li><li><a href=/notes>Notes</a></li><li><a href=/posts>Blog</a></li><li><a href=https://github.com/danclough>Code</a></li><li><a href=https://infosec.exchange/@danclough>Mastodon</a></li><li><a href="https://bellard.org/jslinux/vm.html?cpu=riscv64&amp;url=buildroot-riscv64.cfg&amp;mem=256">Exit</a></li></ul></li></ul></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/posts/pi-5-nvme-killer-feature/>Raspberry Pi 5&rsquo;s NVMe is a Killer Feature</a></h1><div class=post-meta><time class=post-date>2024-02-16</time><span class=post-reading-time>2 min read (352 words)</span></div><span class=post-tags>#<a href=/tags/homelab/>homelab</a>&nbsp;
#<a href=/tags/raspberrypi/>raspberrypi</a>&nbsp;
</span><img src=/images/2024/02/RPi5.jpg class=post-cover alt="Raspberry Pi 5's NVMe is a Killer Feature" title="Cover Image"><div class=post-content><div><p>Running a Kubernetes cluster on a few Raspberry Pi 4s has been a rewarding but challenging experience. The biggest limitation was storage - each Pi was booting from an SD card, which, while convenient, proved to be a massive bottleneck. SD cards are not only slow, but also wear out quickly under constant read/write operations. Over time, I experienced several cases of data corruption which brought that cluster to its knees.</p><p>In fact, I&rsquo;ve got almost 1TB worth of dead (or dying) MicroSD cards in a bench drawer from my endless sacrifices to the Non-Volatile Memory Gods. Constant awareness of this flaw from the resulting expensive heap of silicon pictured below made it very hard to me to trust that cluster for anything beyond experimentation.</p><figure class=center><img src=/images/2024/02/sdcards.png></figure><p>When the Raspberry Pi 5 was announced, its PCIe 3.0 lane immediately caught my eye. I&rsquo;ve toyed with USB-attached SATA and NVMe options in the past, but the limitations and fickleness of USB always made those solutions prone to failure in any number of fun and unpredictable ways. After years of begging and pleading with SD cards and eMMC modules to behave themselves, we finally have a solution! When I took delivery of my Pi5, I paired it with a new <a href=https://argon40.com/products/argon-one-v3-m-2-nvme-case>Argon ONE V3 NVMe case</a> and was incredibly pleased with the result.</p><p>By supporting NVMe storage as a boot option, the Pi 5 significantly improves both performance and durability, making it much more feasible to run small-scale workloads without fear of data loss or SD card failure. This improvement opens up exciting possibilities for homelabs - for small labs and test clusters, it&rsquo;s no longer an ill-fated endeavour to move storage-intensive applications like OpenSearch and Graylog from a traditional x86 rack server to more compact and power-efficient boards like the Pi. My hyperconverged Ceph cluster on Proxmox, which I used to present durable storage to the KubePi cluster, can go back to being mostly idle save for a small number of highly-available VMs running on the hypervisors. For me, this upgrade means my homelab cluster can move beyond hobby-level projects and start handling more serious workloads.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><a href=/posts/whats-in-my-lab-now-2024/ class="button inline prev">What's In My Lab Now, 2024 Edition
</a>::
<a href=/posts/hyperconvergence-ceph-proxmox-homelab/ class="button inline next">The (Hyper)Convergence - Ceph + Proxmox</a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>